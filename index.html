<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <!-- Load the Paper.js library -->
  <script type="text/javascript" src="paper-full.js"></script>
  <!-- Define inlined JavaScript -->
  <style>
    html,
    body {
        height: 100%;
    }

    /* Scale canvas with resize attribute to full size */
    canvas[resize] {
        width: 100%;
        height: 100%;
    }
    #myCanvas{
      border: 1px solid black;
      box-sizing: border-box;
    }
    .tips{
      margin-bottom: 20px;
    }
    .canvas-container{
      width: 3000px;
      height: 5000px;
    }
  </style>
</head>
<body>
  <div class="tips">
    <div>
      <span>新增点位：</span>
      <span>使用alt + 鼠标右键，增加黄点</span>
    </div>
  </div>
	<div class="canvas-container">
    <canvas id="myCanvas" resize></canvas>
  </div>
</body>
<script src="data.js"></script>
<script>

  (function () {
    const blockContextMenu = function (evt) {
      evt.preventDefault();
    };

    const myElement = document.querySelector('#myCanvas');
    myElement.addEventListener('contextmenu', blockContextMenu);
  })();
  const yellowColor = '#e1e111'
  const markDotRadius = 2
  const breakPointRadius = 6
  const keyPointRadius = 8
  const divideNum = 20
  const RIGHT_CLICK = 2
  const canvasHeight = 5000

  paper.install(window);
  window.onload = function() {
    paper.setup('myCanvas');
    // Create a simple drawing tool:
    const tool = new Tool();

    tool.onMouseMove = function onMouseMove(event) {
      project.activeLayer.selected = false;
      if (event.item)
        event.item.selected = true;
    }
    const canvas = document.getElementById('myCanvas')
    const imgRaster = new Raster(figureData.url)
    const keyPoints = [0, 8]
    const breakPointList = []
    const markPointList = []
    const keyPointList = []

    const path = new Path()
    path.strokeColor = yellowColor
    path.strokeWidth = markDotRadius
    path.closed = true

    imgRaster.position = view.center;

    imgRaster.onLoad = function() {
      const widthHeightRate = imgRaster.width / imgRaster.height
      const scaleRate = canvasHeight / imgRaster.height
      imgRaster.height = canvasHeight
      imgRaster.width = canvasHeight * widthHeightRate
      const x = imgRaster.position.x - imgRaster.width / 2
      const y = 0

      const nextPointData = figureData.defaultValue.annotation[0].points
        .map(point => ({
          x: point.x * scaleRate + x,
          y: point.y * scaleRate + y
        }))
      
      const pointList = []
      templateData.lines[1].points.forEach(pointIndex => {
        const dot = nextPointData[pointIndex]
        pointList.push(new Point(dot.x, dot.y))
      })
  
      for(let i = 0; i < pointList.length - 1; i++) {
        path.add(pointList[i])
      }
      initKeyPoints(keyPoints, path.segments)
      initMarkDots(path.segments) // 后绘制的在上面
      initMarkPoints(path.segments)
    }
    

    /*
      初始化方法
    */
    function initMarkDots(segments) {
      segments.forEach((segment, index) => {
        const isEven = index % 2 === 0
        // 偶数个添加黄点
        if(segment.next && isEven) {
          segment.isBreakPoint = true
          breakPointList.push(createDot(segment, breakPointRadius))
        }
      })
    }

    function initKeyPoints(list, segments) {
      list.forEach(pointIndex => {
        segments[pointIndex].isKeyPoint = true
        const keyPoint = createKeyPoint(segments[pointIndex].point, keyPointRadius)
        keyPointList.push(keyPoint)
      })
    }

    function initMarkPoints(segments) {
      const keyPointWithSegments = segments.filter(segment => segment.isKeyPoint)

      for(let i = 0; i < keyPointWithSegments.length; i++) {
        const fromIndex = keyPointWithSegments[i].index
        const toIndex = i === keyPointWithSegments.length - 1 ? segments.length : keyPointWithSegments[i + 1].index
        markPointList.push(...createMarkPoints(fromIndex, toIndex, segments, divideNum))
      }
    }

    function refreshKeyPoints() {
      // 获取所有关键点所在segment
      const keyPointWithSegments = path.segments.filter(segment => segment.isKeyPoint)
      const newMarkPointList = []
      
      // 移动关键点的坐标到新的segment坐标
      for(let i = 0; i < keyPointList.length; i++) {
        keyPointList[i].position = keyPointWithSegments[i].point
      }

      // 根据关键点变化，新生成一批新的标注点
      for(let i = 0; i < keyPointWithSegments.length; i++) {
        const fromIndex = keyPointWithSegments[i].index
        const toIndex = i === keyPointWithSegments.length - 1 ? path.segments.length : keyPointWithSegments[i + 1].index
        newMarkPointList.push(...createMarkPoints(fromIndex, toIndex, path.segments, divideNum))
      }
      // 移动当前标注点到新的标注点
      markPointList.forEach((point, pointIndex) => {
        point.position = newMarkPointList[pointIndex].position
      })
      
      // 删除新生成的标注点
      newMarkPointList.forEach(point => point.removeSegments())
    }

    /*
      创建标记点
      params:{
        from: number #起始segment的index,
        to: number #结束segment的index,
        segments: Array<Segment> #所有的segments
        divideNum: number # 划分的点位个数
      }
    */
    function createMarkPoints(from, to, segments, divideNum) {
      let current = segments[from]
      let lengthTotal = 0 // 两个关键点之间的总长
      const partMarkPointList = []
      const currentSegmentList = [current] // from到to的segment

      for(let i = from; i < to; i++) {
        currentSegmentList.push(current.next)
        current = current.next
      }

      for(let i = 0; i < to - from; i++){
        lengthTotal += currentSegmentList[i].curve.length
      }

      // 单个划分的线段长度
      const divideUnitLen = lengthTotal / divideNum

      current = currentSegmentList[0]
      let currentMarkPoint = createMarkPoint(current.point, markDotRadius)
      partMarkPointList.push(currentMarkPoint)

      for(let i = 1; i < divideNum; i++) {
        const { x: currentX, y: currentY } = currentMarkPoint.position
        const { x: nextX, y: nextY} = current.next.point
        // 代表当前点到目标点的长度
        let newLen = divideUnitLen 
        // 代表结束点到当前点的长度
        let newLeft = calculatePythagorean(currentX, nextX, currentY, nextY)

        // 剩余长度大于单位长度，表示目标点在该线段上
        // 否则目标点在下一个线段上
        if(newLeft >= divideUnitLen) {
          currentMarkPoint = arrangeMarkPoint(currentMarkPoint.position, current.next.point, newLen, newLeft - newLen)
          partMarkPointList.push(currentMarkPoint)
        } else {
          // 剩余长度不够，用单位长度减去剩余长度，得到新的目标点长度
          newLen = divideUnitLen - newLeft
          // 新的剩余长度等于下一线段长度 减去 新的目标点长度
          newLeft = current.next.curve.length - newLen
          // 当前点下移
          current = current.next

          currentMarkPoint = arrangeMarkPoint(current.point, current.next.point, newLen, newLeft)
          partMarkPointList.push(currentMarkPoint)
        }
      }

      return partMarkPointList
    }

    /*
      工具方法
    */
    function findBreakPointIndexInSegments(breakPoint, segments) {
      for(let i = 0; i < segments.length; i++) {
        const {x: segmentX, y: segmentY } = segments[i].point
        const {x: breakPointX, y: breakPointY } = breakPoint.position

        if(segmentX === breakPointX && segmentY === breakPointY) {
          return i
        }
      }
    }

    function findSegmentIndexInBreakPoints(segment, pointList) {
      for(let i = 0; i < pointList.length; i++) {
        const {x: segmentX, y: segmentY } = segment.point
        const {x: breakPointX, y: breakPointY } = pointList[i].position

        if(segmentX === breakPointX && segmentY === breakPointY) {
          return i
        }
      }
    }

    // 计算直角三角形对边
    function calculatePythagorean(x1, x2, y1, y2) {
      const x = Math.pow((x1 - x2), 2)
      const y = Math.pow((y1 - y2), 2)
      return Math.sqrt(x + y)
    }

    // 给定两个坐标，以及长度，计算目标点坐标
    function calculateLinearOneUnknown(x1, x2, y1, y2, len, left) {
      const y = (len * y2 + y1 * left) / (left + len)
      const x = (len * x2 + x1 * left) / (left + len)
      return {
        x, y
      }
    }

    function logPointPosition(list) {
      const result = []
      list.forEach((item) => {
        result.push({
          x: item.position.x,
          y: item.position.y
        })
      })
      console.log(result)
    }

    function refreshBreakPoint(currentPointId) {
      for(let i = 0; i < breakPointList.length; i++) {
        const breakPoint = breakPointList[i]

        if(currentPointId === breakPoint.id) continue

        // 找到点位在segments里的index
        const breakPointIndexInPath = findBreakPointIndexInSegments(breakPoint, path.segments)
        // 把拐点删了
        breakPoint.removeSegments()
        // 以最新的segment去创建拐点
        breakPointList[i] = createDot(path.segments[breakPointIndexInPath], breakPointRadius)
      }
    }

    function arrangeMarkPoint(current, toSegment, len, left) {
      const { x: currentX, y: currentY } = current
      const { x: nextX, y: nextY} = toSegment

      const {
        x: newX,
        y: newY
      } = calculateLinearOneUnknown(currentX, nextX, currentY, nextY, len, left)
      return createMarkPoint(new Point(newX, newY), markDotRadius)
    }

    const hitOptions = {
      stroke: true,
      tolerance: 5
    }

    path.onMouseDown = function(event) {
      const { point } = event
      const hitResult = project.hitTest(event.point, hitOptions);

      if(!hitResult) return
      if(!Key.isDown('alt') || event.event.button !== RIGHT_CLICK) return

      const nextPoint = new Point(event.point)
      const nextIndex = hitResult.location.index + 1
      path.insert(nextIndex, nextPoint)
      path.segments[nextIndex].isBreakPoint = true

      const nextBraekPointSegment = path.segments[nextIndex].next
      const previousBreakPointSegment = path.segments[nextIndex].previous
      let currentBreakPointIndex = 0

      //如果下一个点是拐点，当前点index去下一个拐点的index
      if(nextBraekPointSegment.isBreakPoint) {
        currentBreakPointIndex = findSegmentIndexInBreakPoints(nextBraekPointSegment, breakPointList)
      }

      //上一个点是拐点的情况
      if(previousBreakPointSegment.isBreakPoint) {
        currentBreakPointIndex = findSegmentIndexInBreakPoints(previousBreakPointSegment, breakPointList)
        // 因为上一个是拐点，所以当前点index需要加一
        currentBreakPointIndex = currentBreakPointIndex + 1
      }

      const nextBreakPoint = createDot(path.segments[nextIndex], breakPointRadius)
      
      breakPointList.splice(currentBreakPointIndex, 0, nextBreakPoint)
      refreshBreakPoint(nextBreakPoint.id)
    }

    /*
      点创建方法
    */

    function createDot(segment, radius) {
      let index = segment.index
      const newDot = new Path.Circle(segment.point, radius)

      newDot.fillColor = yellowColor
      newDot.onMouseDrag = function dotDrag(event) {
        const currentSegment = path.segments[index]
        const currentSegmentIsKeyPoint = currentSegment.isKeyPoint

        newDot.position = event.point

        // 如果上一个segment和下一个segment都是拐点，直接移动
        if(currentSegment.previous.isBreakPoint && currentSegment.next.isBreakPoint) {
          path.removeSegment(index)
          path.insert(index, event.point)
          path.segments[index].isBreakPoint = true
          path.segments[index].isKeyPoint = currentSegmentIsKeyPoint
          return
        }

        // 上一个segment不是拐点，删除上一个segment，拉平
        if(!currentSegment.previous.isBreakPoint) {
          path.removeSegment(currentSegment.previous.index)
          index = index > 0 ? index - 1 : index // 当index为0，代表当前是头节点，index不变
        }

        // 下一个segment不是拐点，删除segment
        if(!currentSegment.next.isBreakPoint){
          path.removeSegment(currentSegment.next.index)
        }
        
        path.removeSegment(index)
        path.insert(index, event.point)
        path.segments[index].isBreakPoint = true
        path.segments[index].isKeyPoint = currentSegmentIsKeyPoint
        // 删除segment，因为闭包，导致index改变了，所以要更新所有点位
        refreshBreakPoint(newDot.id)
      }

      newDot.onMouseUp = function(event) {
        const currentSegment = path.segments[index]

        // 当拖动的是关键点，刷新所有点位
        if(currentSegment.isKeyPoint){
          refreshKeyPoints()
          return
        }
      
        let tempSegment = currentSegment.previous
        let startX = 0          // 起始segment，也就是起始mark点 x坐标
        let startY = 0          // y坐标
        let endX = 0            // 结束segment，也就是结束mark点 x坐标
        let endY = 0            // y坐标
        let startIndex = 0      // 起始mark点的index
        let endIndex = 0        // 结束mark点的index

        // 迭代segment，找到最近相邻的两个keyPointSegment
        while(!tempSegment.isKeyPoint) {
          tempSegment = tempSegment.previous
        }
        const fromIndex = tempSegment.index // 起始segment的index
        startX = tempSegment.point.x
        startY = tempSegment.point.y

        tempSegment = currentSegment.next
        while(!tempSegment.isKeyPoint) {
          tempSegment = tempSegment.next
        }
        endX = tempSegment.point.x
        endY = tempSegment.point.y
        // 结束segment的index
        // 如果最后一个指向index 0，代表最后一段，也就是segments的长度
        const toIndex = tempSegment.index === 0 ? path.segments.length : tempSegment.index

        // 循环所有的mark点，直到找到第一个坐标和起始segment坐标一致，当前的index就是起始
        for(let i = 0; i < markPointList.length; i++) {
          const { x: markX, y: markY } = markPointList[i].position
          if(markX === startX && markY === startY) {
            startIndex = i
            break
          }
        }
        // 起始mark点的index 加上 点位个数，可以得到结束index
        endIndex = startIndex + divideNum

        const partMarkPointList = createMarkPoints(fromIndex, toIndex, path.segments, divideNum)

        // 根据起始结束index，更改mark点的坐标
        for(let i = startIndex; i < endIndex; i++) {
          markPointList[i].position = partMarkPointList[i - startIndex].position
        }
        // 删除新生成的点位
        partMarkPointList.forEach(point => point.removeSegments())
      }
      return newDot
    }

    function createMarkPoint(point, radius) {
      const newDot = new Path.Circle(point, radius)

      newDot.fillColor = 'red'
      return newDot
    }

    function createKeyPoint(point, radius) {
      const newDot = new Path.Circle(point, radius)
      newDot.fillColor = 'blue'

      return newDot
    }
  }

  // 工具栏按钮
</script>
</html>
